// Copyright 2021 Innoviz Technologies
//
// Licensed under the Innoviz Open Dataset License Agreement (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://github.com/InnovizTechnologies/InnovizAPI/blob/master/LICENSE.md
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef __ACP_H__
#define __ACP_H__

/**
 * @file ACP.h
 */

#define ACP_HEADER_PROTO_TYPE_RESPONSE_BIT_MASK    0x80
#define ACP_PROTOCOL_VERSION 1
#define MARKER 0xCAFEBABE
#define MASTER_ID 1
#define COMMUNICATION_OPTIONS 0
#define  SPI_MESSAGE_SIZE 128 

#define  SPI_DATA_SIZE SPI_MESSAGE_SIZE-16-8-4 //128 - 16 (header) - 8 ( type,length) -4 (CRC)= 100
#define ACP_PACKET_OVERHEADS 28
#define ACP_GET_DP_MSG_OVERHEADS (ACP_PACKET_OVERHEADS + 8)
#define ACP_SET_DP_MSG_OVERHEADS (ACP_PACKET_OVERHEADS + 12)
#define ACP_PACKET_MAX_SIZE 32000
#define GET_PARAM_MAXSIZE SPI_DATA_SIZE - 4 - 4 //(- Returncode - ParameterId)
#define SET_PARAM_MAXSIZE SPI_DATA_SIZE - 4 - 4 - 4
#define  MAX_DIRECT_GET_SIZE GET_PARAM_MAXSIZE // max parameter size for direct get
#define MIN_REGISTER_WIDTH 1
#define MAX_REGISTER_WIDTH 32

#define ACP_TLV_TYPE_OP_CODE_MASK 0x0000FFFF
#define ACP_TLV_TYPE_MASTER_ID_MASK 0x00FF0000
#define ACP_TLV_TYPE_MASTER_ID_AND_OP_MASK (ACP_TLV_TYPE_OP_CODE_MASK | ACP_TLV_TYPE_MASTER_ID_MASK)
#define ACP_TLV_TYPE_RESPONSE_MASK 0x80000000
#define ACP_TLV_TYPE_RETURN_CODE_MASK 0x40000000


namespace invz
{
	//options for ACP message set in header
	enum ACPOptions {
		OPTION_NO_RESPONSE = 0x00,
		OPTION_REMOTE_DEVICE = 0x01,
		OPTION_CRC32_REQUIRED = 0x06,
		OPTION_RESPONSE_RQUIRED = 0x08,
		OPTION_RESPONSE_CRC32_RQUIRED = OPTION_CRC32_REQUIRED | OPTION_RESPONSE_RQUIRED
	};

	/* ACP protocol types
	*/
	enum ACPType {
		ACPTYPE_CONTROL =		0,
		ACPTYPE_DEBUGGING =		1,
		ACPTYPE_UNSOLICITED =	2,
		ACPTYPE_FW_UPGRADE =	3,
		ACPTYPE_KEEP_ALIVE =	5,
		ACPTYPE_DUMMY =			6,

		ACPTYPE_CONTROL_RESP = (ACPTYPE_CONTROL | ACP_HEADER_PROTO_TYPE_RESPONSE_BIT_MASK),
		ACPTYPE_DEBUGGING_RESP = (ACPTYPE_DEBUGGING | ACP_HEADER_PROTO_TYPE_RESPONSE_BIT_MASK),
		ACPTYPE_UNSOLICITED_RESP = (ACPTYPE_UNSOLICITED | ACP_HEADER_PROTO_TYPE_RESPONSE_BIT_MASK),
		ACPTYPE_FW_UPGRADE_RESP = (ACPTYPE_FW_UPGRADE | ACP_HEADER_PROTO_TYPE_RESPONSE_BIT_MASK),
		ACPTYPE_KEEP_ALIVE_RESP = (ACPTYPE_KEEP_ALIVE | ACP_HEADER_PROTO_TYPE_RESPONSE_BIT_MASK),
		ACPTYPE_DUMMY_RESP = (ACPTYPE_DUMMY | ACP_HEADER_PROTO_TYPE_RESPONSE_BIT_MASK),

		ACPTYPE_TYPE_MAX
	};
	
	/*
	Module ids
	*/
	enum ModuleId {
		MODULE_GENERAL_PURPOSE_OPCODE = 0x000000,
		MODULE_DEBUGGING =				0x010000,
		MODULE_DTC =					0x020000,
		MODULE_FW_UPGRADE =				0x030000,
		MODULE_DLT =					0x040000,
		MODULE_POINT_CLOUD_DATA =		0x050000,
		MODULE_LIDAR_DATA =				0x060000,
		MODULE_TRACES =					0x070000,
		MODULE_CONTROL_AND_STATUS =		0x080000,
		MODULE_CM_DATA =				0x100000,
		MODULE_INVZ_FILE =				0x0F0000,
        MODULE_POINT_CLOUD_PIXELS =     0xFF0000, // A virtual module, generated by the API
	};

	enum GeneralPurpose
	{
		GENERAL_SET_FW_MODE = MODULE_GENERAL_PURPOSE_OPCODE | 0x1001,
		GENERAL_GET_FW_MODE = MODULE_GENERAL_PURPOSE_OPCODE | 0x1002

	};
	
	enum Traces
	{
		TRACES_TAP_PARTIAL = MODULE_TRACES | 0x401,
		TRACES_TAP_DILUTION = MODULE_TRACES | 0x402
	};

	enum CMData
	{
		OBJECT_DETECTION_DEBUG_PORT						= MODULE_CM_DATA | 0x0001, // Debug Port object detection TLV
		TRACKED_OBJECT_DEBUG_PORT						= MODULE_CM_DATA | 0x000A, // Debug Port tracked object TLV
		SENSOR_POSE_DEBUG_PORT							= MODULE_CM_DATA | 0x0011, // Debug Port sensor pose TLV
		PC_PLUS_METADATA								= MODULE_CM_DATA | 0x1001, // PC+ meta TLV over debug port and service interface
		PC_PLUS_DETECTION								= MODULE_CM_DATA | 0x1002, // PC+ detection TLV over debug port and service interface
        PC_PLUS_48K_METADATA                            = MODULE_CM_DATA | 0x1010, // PC+ 48 K meta TLV over debug port and service interface
		OBJECT_DETECTION								= MODULE_CM_DATA | 0x1007, // Object detection TLV over debug port and service interface
		TRACKED_OBJECT									= MODULE_CM_DATA | 0x1003, // Tracked object TLV over debug port and service interface
		OC_OUTPUT_DEBUG_PORT							= MODULE_CM_DATA | 0x000E, // Online Calibration TLV over debug port 
		DC_OUTPUT_DEBUG_PORT							= MODULE_CM_DATA | 0x0010  // Dynamic Calibration TLV over debug port
	};

	enum LidarData
	{
		LIDAR_HEATER_DATA = MODULE_LIDAR_DATA | 0x0040,
	};

	// Diagnostic message type
	enum GeneralType
	{
		GENERAL_HELLO =						MODULE_GENERAL_PURPOSE_OPCODE | 0x0000,
		GENERAL_GET_PARAMETER =				MODULE_GENERAL_PURPOSE_OPCODE | 0x0001, //Get Parameter Get Parameter from Embedded system
		GENERAL_SET_PARAMETER =				MODULE_GENERAL_PURPOSE_OPCODE | 0x0002, //Set Parameter Value 
		GENERAL_GET_PARAMETER_PARTIALY =		MODULE_GENERAL_PURPOSE_OPCODE | 0x0003, //Get Parameter partially Read only a part of the parameter
		GENERAL_SET_PARAMETER_PARTIALY =		MODULE_GENERAL_PURPOSE_OPCODE | 0x0004, //Set only a part of a parameter 
		GENERAL_ACTIVATE_TAP =					MODULE_GENERAL_PURPOSE_OPCODE | 0x0005, //Change Tap State Enable or Disable Tap
		GENERAL_BURN_PARAMETER =				MODULE_GENERAL_PURPOSE_OPCODE | 0x0006,//Burn a single parameter to flash 
		GENERAL_BURN_PARAMETER_PARTIALY=		MODULE_GENERAL_PURPOSE_OPCODE | 0x0007,// Burn Parameter partially Burn a part of a parameter in NVM
		GENERAL_BURN_CURRENT_VALUE =			MODULE_GENERAL_PURPOSE_OPCODE | 0x0008,//Write the current value of the parameter to NVM 
		GENERAL_READ_MEMORY=					MODULE_GENERAL_PURPOSE_OPCODE | 0x0009,// Read memory Development feature only
		GENERAL_WRITE_MEMORY=					MODULE_GENERAL_PURPOSE_OPCODE | 0x000A, //Write memory Development feature only 
		GENERAL_READ_FLASH=					MODULE_GENERAL_PURPOSE_OPCODE | 0x000B,// Read Flash Development feature only
		GENERAL_WRITE_FLASH =				MODULE_GENERAL_PURPOSE_OPCODE | 0x000C,// write Flash Development feature only
		GENERAL_INDIRECT_GET_PARAMETER =		MODULE_GENERAL_PURPOSE_OPCODE | 0x000D, // Get parameter indirect
		GENERAL_INDIRECT_GET_PARAMETER_PARTIALY =		MODULE_GENERAL_PURPOSE_OPCODE | 0x000E, // Get parameter indirect
		GENERAL_READ_REGISTER =					MODULE_GENERAL_PURPOSE_OPCODE | 0x000F, // Read register directly
		GENERAL_WRITE_REGISTER =				MODULE_GENERAL_PURPOSE_OPCODE | 0x0010, // Write register directly
		GENERAL_READ_NOR = MODULE_GENERAL_PURPOSE_OPCODE |  0x0014, // Read register directly
		GENERAL_WRITE_NOR = MODULE_GENERAL_PURPOSE_OPCODE | 0x0015, // Write register directly
		GENERAL_ERASE_NOR = MODULE_GENERAL_PURPOSE_OPCODE | 0x0016, // Write register directly
		GENERAL_WRITE_FILE=						MODULE_GENERAL_PURPOSE_OPCODE | 0x0020,
		GENERAL_READ_FILE =						MODULE_GENERAL_PURPOSE_OPCODE | 0x0021,
		GENERAL_DELETE_FILE =					MODULE_GENERAL_PURPOSE_OPCODE | 0x0022,
		GENERAL_READ_DIR =						MODULE_GENERAL_PURPOSE_OPCODE | 0x0023,

	};
	
	enum PointCloudType
	{
		POINT_CLOUD_BLOCKAGE_ENVIRONMENTAL =	MODULE_POINT_CLOUD_DATA | 0x0012,
		POINT_CLOUD_BLOCKAGE_DETECTION =		MODULE_POINT_CLOUD_DATA | 0x0013,
		POINT_CLOUD_BLOCKAGE_CLASSIFICATION =	MODULE_POINT_CLOUD_DATA | 0x0014,
		POINT_CLOUD_INVZ4_PIXELS =				MODULE_POINT_CLOUD_DATA | 0x0016,
		POINT_CLOUD_CSAMPLE_METADATA =			MODULE_POINT_CLOUD_DATA | 0x0017,
		POINT_CLOUD_END_OF_FRAME =				MODULE_POINT_CLOUD_DATA | 0x0020,
		POINT_CLOUD_LIDAR_STATUS =				MODULE_POINT_CLOUD_DATA | 0x0041,
		POINT_CLOUD_VIRTUAL_CHANNEL_FRAME_START =	MODULE_POINT_CLOUD_DATA | 0x00FF,
	};

    enum PointCloudPixelsType
    {
        POINT_CLOUD_PIXELS_MEASUREMENTS =       MODULE_POINT_CLOUD_PIXELS | 0xFF00,
        POINT_CLOUD_PIXELS_DIRECTIONS =         MODULE_POINT_CLOUD_PIXELS | 0xFF01,
        POINT_CLOUD_PIXELS_SUM_MEASUREMENTS =   MODULE_POINT_CLOUD_PIXELS | 0xFF02,
        POINT_CLOUD_PIXELS_SUM_DIRECTIONS =     MODULE_POINT_CLOUD_PIXELS | 0xFF03,
        POINT_CLOUD_PIXELS_PC_PLUS =			MODULE_POINT_CLOUD_PIXELS | 0xFF04,
        POINT_CLOUD_PIXELS_THETA_PHI =			MODULE_POINT_CLOUD_PIXELS | 0xFF05,
        POINT_CLOUD_PIXELS_IS_VALID =			MODULE_POINT_CLOUD_PIXELS | 0xFF06,
        POINT_CLOUD_PIXELS_SUM_IS_VALID =		MODULE_POINT_CLOUD_PIXELS | 0xFF07,
		//POINT_CLOUD_PIXELS_GHOST =              MODULE_POINT_CLOUD_PIXELS | 0xFF08,
		POINT_CLOUD_MACRO_PIXEL_META_DATA=      MODULE_POINT_CLOUD_PIXELS | 0xFF0C,
		POINT_CLOUD_SINGLE_PIXEL_META_DATA=     MODULE_POINT_CLOUD_PIXELS | 0xFF0D,
		POINT_CLOUD_SUM_PIXEL_META_DATA =    MODULE_POINT_CLOUD_PIXELS | 0xFF0E,



	};

    constexpr uint32_t POINT_CLOUD_PIXELS_MINOR_TYPE_REFLECTION_MASK = 0xF;
    
	constexpr uint32_t POINT_CLOUD_PIXELS_MINOR_TYPE_REFLECTION_SHIFT = 0;

	// Control message type
	enum ControlType {
		CONTROL_PING =					MODULE_CONTROL_AND_STATUS | 0x0001,
		CONTROL_SET_BYPASS_MODE =		MODULE_CONTROL_AND_STATUS | 0x0002,
		CONTROL_SET_HEATER =			MODULE_CONTROL_AND_STATUS | 0x0003,
		CONTROL_GET_SET_STATE =			MODULE_CONTROL_AND_STATUS | 0x0004,
		CONTROL_MIRROR_PITCH =			MODULE_CONTROL_AND_STATUS | 0x0005,
		CONTROL_INITIAL_NEGOTIATION =	MODULE_CONTROL_AND_STATUS | 0x0010,
		STATUS_RUN_TIME_LOG =			MODULE_CONTROL_AND_STATUS | 0x0019
	};

	enum InvzFileType
	{
		INVZ_FILE_HEADER =		MODULE_INVZ_FILE | 0x0001,
		INVZ_FILE_DIRECTIONS =	MODULE_INVZ_FILE | 0x0002,
		INVZ_FILE_TIMINGS =		MODULE_INVZ_FILE | 0x0003
	};
	/*
	Target for ping request
	*/
	enum PingTarget
	{
		PING_TARGET_SPI,
		PING_TARGET_MIPI
	};
	
	//Firmware upgrade message types
	enum FWUpgradeType {
		FW_UPGRADE_START =			MODULE_FW_UPGRADE | 0x0001,
		FW_UPGRADE_STATUS =			MODULE_FW_UPGRADE | 0x0002,
		FW_UPGRADE_DATA_PACKET =	MODULE_FW_UPGRADE | 0x0003,
		FW_UPGRADE_NAK =			MODULE_FW_UPGRADE | 0x0004,
		FW_UPGRADE_END =			MODULE_FW_UPGRADE | 0x0005

	};

	//Firmaware mode
	enum FWMode {
		UPGRADE_MODE = 0x01,
		REGULAR_MODE = 0x02
	};
	
	enum FWModeResult {
		GET_FW_UPGRADE =	0x1021,
		GET_FW_NORMAL =		0x1022, 
		GET_FW_INIT =		0x1023

	};

	//return codes for FW_UPGRADE_START
	enum FWUpgradeStartResult {
		UPGRADE_START_ERASE_IN_PROGRESS =	0x1001,
		UPGRADE_START_ERASED =				0x1002,
		UPGRADE_AUTH_FAILED =				0x2001,
		UPGRADE_TOO_LONG =					0x2002,
		UPGRADE_INVALID_TLV =				0x0009

	};

	//return codes for FW_UPGRADE_STATUS
	enum FWUpgradeStatusResult {
		UPGRADE_STATUS_NO_START =			0x1000,
		UPGRADE_STATUS_ERASING =			0x1001,
		UPGRADE_STATUS_ERASED =				0x1002,
		UPGRADE_STATUS_UPGRADE_ERROR =		0x1003,
		UPGRADE_STATUS_BURNING =			0x1004,
		UPGRADE_STATUS_BURNING_COMPLETED =	0x1005,
		UPGRADE_STATUS_CRC_FAILED =			0x1006,
		UPGRADE_STATUS_AUTH_FAILED =		0x1007,
		UPGRADE_STATUS_SUCCESS =			0x1008,
		UPGRADE_STATUS_AUTHENTICATING =		0x1009
	};
	
	enum ACPReturnCode {
		ACP_RETURN_CODE_ACK_OK = 0x0000,
		ACP_RETURN_CODE_ACK_OK_100 = 0x0100,   // we dont use
		ACP_RETURN_CODE_CRC_ERROR = 0x0101,
		ACP_RETURN_CODE_OUT_OF_ORDER_FRAME = 0x0104,
		ACP_RETURN_CODE_TIMEOUT = 0x0105,
		ACP_RETURN_CODE_FRAME_OVERFLOW = 0x0106,
		ACP_RETURN_CODE_FRAME_UNDERFLOW = 0x0107,
		ACP_RETURN_CODE_INVALID_HEADER = 0x0108,
		ACP_RETURN_CODE_INVALID_PROTOCOL_TYPE = 0x0109,
		ACP_RETURN_CODE_INVALID_PROTOCOL_VERSION = 0x010A,
	};

	enum TlvReturnCode
	{
		TLV_RETURN_CODE_OK = 0x0000,
		TLV_RETURN_CODE_UNPERMITTED_ACCESS,
		TLV_RETURN_CODE_NOT_IMPLEMENTED,
		TLV_RETURN_CODE_INVALID_ARGUMENT,
		TLV_RETURN_CODE_SETUP_FAILED,
		TLV_RETURN_CODE_FILE_ERROR,
		TLV_RETURN_CODE_NETWORK_ERROR,
		TLV_RETURN_CODE_SEND_FAILED,
		TLV_RETURN_CODE_RECIEVE_FAILED,
		TLV_RETURN_CODE_NOT_ENOUGH_MEM,
		TLV_RETURN_CODE_VALUE_ERROR,
		TLV_RETURN_CODE_TIMEOUT
	};

	enum AcpNorPartition : uint32_t {
		NOR_PARTITION_BOOTLOADER_IMAGE	= 0x0000,
		NOR_PARTITION_SW_A				= 0x0001,
		NOR_PARTITION_SW_B				= 0x0002,
		NOR_PARTITION_VERSION_SELECT	= 0x0003,
		NOR_PARTITION_SAFETY_JOURNAL	= 0x0004,
		NOR_PARTITION_PARAMS_A			= 0x0005,
		NOR_PARTITION_PARAMS_B			= 0x0006
	};

	/*---------- TLV Values structs ----------*/
#pragma pack(push, 1)
	struct TlvValue_HelloMessageResponse
	{
		uint32_t paramVersion;
		uint8_t loginActualLevel;
	};

	struct TlvValue_GetParameterResponse
	{
		uint32_t returnCode;
		uint32_t parameterId;
		uint8_t parameterData[];
	};

	struct TlvValue_GetParameterPartiallyResponse
	{
		uint32_t returnCode;
		uint32_t parameterId;
		uint32_t dataSize;
		uint32_t offset;
		uint8_t parameterData[];
	};

	struct TlvValue_IndirectGetParameterPartiallyResponse
	{
		uint32_t parameterId;
		uint32_t dataSize;
		uint32_t offset;
		uint8_t parameterData[];
	};

	struct TlvValue_SetParameterRequest
	{
		uint32_t parameterId;
		uint8_t parameterData[];
	};

	struct TlvValue_SetParameterPartiallyRequest
	{
		uint32_t parameterId;
		uint32_t dataSize;
		uint32_t offset;
		uint8_t parameterData[];
	};

	struct TlvValue_PartialTap
	{
		uint32_t id;
		uint32_t offset;
		uint32_t frameNumber;
		uint8_t data[];
	};

	struct TlvValue_DilutionTap
	{
		uint32_t id;
		uint32_t ui_cookie;
		uint32_t size;
		uint32_t offset;
		uint32_t horizontal_dilution;
		uint32_t vertical_dilution;
		uint32_t frameNumber;
		uint8_t data[];
	};

	struct TlvValue_ReadRegister
	{
		uint32_t address;
		uint32_t width;
		uint32_t offset;
	};

	struct TlvValue_WriteRegister
	{
		uint32_t address;
		uint32_t width;
		uint32_t offset;
		uint32_t value;
	};

	struct TlvValue_LogMessage
	{
		/*uint32_t id;*/
		uint32_t severity;
		uint32_t timestamp;
		char msg[];
	};

	struct TlvValue_ReadNorPartitionResponse
	{
		uint32_t errorCode;
		uint32_t partitionSize;
		uint8_t data[];
	};

	struct ACPMessageListDirResponse {
		uint32_t error;
		uint16_t dir_size;
		uint16_t reserved;
		uint32_t len;
		char data[0];
	};

	struct TlvValue_NegotiationRequest {
		uint8_t access_level;   // (1 byte: access level, 1 byte: vendor param, 1 byte: vendor param ext, 1 byte: reserved)
		uint8_t vendor_param = 0;
		uint8_t vendor_param_ext = 0;
		uint8_t reserved1;
		uint8_t access_key[20];
		uint8_t reserved2[20];
	};

	struct TlvValue_NegotiationResponse {
		uint16_t protocol_version;       // 2 bytes: protocol version, 2 bytes: device type
		uint16_t device_type;
		uint32_t hw_version;
		uint32_t reserved1;
		uint32_t fw_version;
		uint16_t reserved2;
		uint16_t access_level; // 2 bytes: reserved, 2 bytes: access level granted
		uint32_t param_json_version;
		uint8_t serial_number[20];
		uint32_t error_code;
		uint8_t mode;        // 1 byte: mode, 1 byte: submode, 2 bytes: power on reason
		uint8_t sub_mode;        
		uint16_t po_reason;
		uint16_t po_count; //2 bytes power on count, 2 bytes vin[0 to 1]
		uint16_t vin_0_1;
		uint32_t vin_2_5;               // vin [2 to 5]
		uint32_t vin_6_9;               // vin [6 to 9]
		uint32_t vin_10_13;             // vin[10 to 13]
		uint32_t vin_14_16_sw_ver_type; // vin[14 to 16] and last byte is sw_ver_type
	};
#pragma pack(pop)
}

#endif /*__ACP_H__*/